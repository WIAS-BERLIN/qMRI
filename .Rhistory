install.packages("adimpro")
install.packages("dti")
library(qMRI)
source('~/.active-rstudio-document', echo=TRUE)
mpmsp1
modelMPMQL2 <- estimateESTATICS(mpmsp1,
method = "QL",
sigma = sigma,
L = 1,
verbose = FALSE)
?estimateESTATICS
mpmsp1$=
names(mpmsp1)
modelMPMQLsp1
names(modelMPMQLsp1)
modelMPMQLsp1$smoothedData
# evaluate this here to be able to reduce the mask afterwards
# setCores(2)
modelMPMQLsp1 <- smoothESTATICS(modelMPM,
mpmData = extract(mpm, "ddata"),
kstar = 16,
alpha = 0.004,
patchsize = 1,
verbose = FALSE)
?smoothESTATICS
modelMPM
extract(mpm, "ddata")
?mpmdata
?estimateESTATICS
mpm
names(mpm)
library(qMRI)
?ActivityIndex::ReadGT3XPlus("/Users/johnmuschelli/Dropbox/Packages/ActivityIndex/inst/extdata/sample_GT3X+.csv.gz")
library(ActivityIndex)
filename = system.file("extdata","sample_GT3X+.csv.gz",
package="ActivityIndex")
res = ActivityIndex::ReadGT3XPlus(filename)
data = res$Raw
library(fst)
library(ActivityIndex)
library(fst)
filename = system.file("extdata","sample_GT3X+.csv.gz",
package="ActivityIndex")
res = ActivityIndex::ReadGT3XPlus(filename)
data = res$Raw
class(data)
library(ActivityIndex)
library(fst)
filename = system.file("extdata","sample_GT3X+.csv.gz",
package="ActivityIndex")
res = ActivityIndex::ReadGT3XPlus(filename)
data = res$Raw
df = as.data.frame(data)
fst_file = tempfile(fileext = ".fst")
fst::write_fst(df, fst_file)
fst_df = fst::fst(fst_file)
dt_fst_file = tempfile(fileext = ".fst")
fst::write_fst(data, dt_fst_file)
fst_dt = fst::fst(dt_fst_file)
fst_df
library(ActivityIndex)
library(fst)
library(lubridate)
filename = system.file("extdata","sample_GT3X+.csv.gz",
package="ActivityIndex")
res = ActivityIndex::ReadGT3XPlus(filename)
data = res$Raw
data$DT = paste(data$Date, data$Time)
data$DT = ymd_hms(data$DT)
df = as.data.frame(data)
fst_file = tempfile(fileext = ".fst")
fst::write_fst(df, fst_file)
fst_df = fst::fst(fst_file)
sub_df = fst_df[ fst_df$Time >= as]
fst_df
sub_df = fst_df[ fst_df$Time >= ymd_hms("2012-06-27 11:00:00") &
fst_df$Time <= ymd_hms("2012-06-27 12:00:00")]
sub_df = fst_df[ fst_df$Time >= ymd_hms("2012-06-27 11:00:00") &
fst_df$Time <= ymd_hms("2012-06-27 12:00:00"), ]
sub_df = fst_df[ fst_df$DT >= ymd_hms("2012-06-27 11:00:00") &
fst_df$DT <= ymd_hms("2012-06-27 12:00:00"), ]
head(sub_df)
class(sub_df)
class(fst_df)
library(ActivityIndex)
library(fst)
library(lubridate)
filename = system.file("extdata","sample_GT3X+.csv.gz",
package="ActivityIndex")
res = ActivityIndex::ReadGT3XPlus(filename)
data = res$Raw
data$DT = paste(data$Date, data$Time)
data$DT = ymd_hms(data$DT)
df = as.data.frame(data)
fst_file = tempfile(fileext = ".fst")
fst::write_fst(df, fst_file)
fst_df = fst::fst(fst_file)
class(fst_df)
is.data.frame(fst_df)
sub_df = fst_df[ fst_df$DT >= ymd_hms("2012-06-27 11:00:00") &
fst_df$DT <= ymd_hms("2012-06-27 12:00:00"), ]
is.data.frame(sub_df)
class(fst_dt)
fst_dt
?fst::fst
?fst::read_fst()
library(ActivityIndex)
library(fst)
library(lubridate)
library(data.table)
filename = system.file("extdata","sample_GT3X+.csv.gz",
package="ActivityIndex")
res = ActivityIndex::ReadGT3XPlus(filename)
data = res$Raw
data$DT = paste(data$Date, data$Time)
data$DT = ymd_hms(data$DT)
?setkey()
head(data)
library(ActivityIndex)
library(fst)
library(lubridate)
library(data.table)
filename = system.file("extdata","sample_GT3X+.csv.gz",
package = "ActivityIndex")
res = ActivityIndex::ReadGT3XPlus(filename)
data = res$Raw
data$DT = paste(data$Date, data$Time)
data$DT = ymd_hms(data$DT)
setkey(data, DT)
head(data)
df = as.data.frame(data)
fst_file = tempfile(fileext = ".fst")
fst::write_fst(df, fst_file)
fst_df = fst::fst(fst_file)
class(fst_df)
is.data.frame(fst_df)
sub_df = fst_df[ fst_df$DT >= ymd_hms("2012-06-27 11:00:00") &
fst_df$DT <= ymd_hms("2012-06-27 12:00:00"), ]
is.data.frame(sub_df)
dt_fst_file = tempfile(fileext = ".fst")
fst::write_fst(data, dt_fst_file)
fst_dt = fst::fst(dt_fst_file)
class(fst_dt)
fst_dt
dt = read_fst(dt_fst_file, as.data.table = TRUE)
head(dt)
key(dt)
key(fst_dt)
?fst
#######################
# Write out fst files
#######################
fst_file = tempfile(fileext = ".fst")
library(ActivityIndex)
library(fst)
library(lubridate)
library(data.table)
filename = system.file("extdata","sample_GT3X+.csv.gz",
package = "ActivityIndex")
res = ActivityIndex::ReadGT3XPlus(filename)
data = res$Raw
data$DT = paste(data$Date, data$Time)
data$DT = ymd_hms(data$DT)
setkey(data, DT)
object.size(data)
df = as.data.frame(data)
object.size(df)
object.size(df, units = "Mb")
format(object.size(df), units = "Mb")
format(object.size(data), units = "Mb")
library(ActivityIndex)
library(fst)
library(lubridate)
library(data.table)
filename = system.file("extdata","sample_GT3X+.csv.gz",
package = "ActivityIndex")
res = ActivityIndex::ReadGT3XPlus(filename)
data = res$Raw
data$DT = paste(data$Date, data$Time)
data$DT = ymd_hms(data$DT)
setkey(data, DT)
format(object.size(data), units = "Mb")
df = as.data.frame(data)
format(object.size(df), units = "Mb")
#######################
# Write out fst files
#######################
fst_file = tempfile(fileext = ".fst")
fst::write_fst(df, fst_file)
fst_df = fst::fst(fst_file)
class(fst_df)
format(object.size(fst_df), units = "Mb")
library(ActivityIndex)
library(fst)
library(lubridate)
library(data.table)
filename = system.file("extdata","sample_GT3X+.csv.gz",
package = "ActivityIndex")
res = ActivityIndex::ReadGT3XPlus(filename)
data = res$Raw
data$DT = paste(data$Date, data$Time)
data$DT = ymd_hms(data$DT)
setkey(data, DT)
format(object.size(data), units = "Mb")
df = as.data.frame(data)
format(object.size(df), units = "Mb")
#######################
# Write out fst files
#######################
fst_file = tempfile(fileext = ".fst")
fst::write_fst(df, fst_file)
fst_df = fst::fst(fst_file)
class(fst_df)
format(object.size(fst_df), units = "Mb")
is.data.frame(fst_df)
object.size(fst_df)
sub_df = fst_df[ fst_df$DT >= ymd_hms("2012-06-27 11:00:00") &
fst_df$DT <= ymd_hms("2012-06-27 12:00:00"), ]
is.data.frame(sub_df)
format(object.size(sub_df), units = "Mb")
# use data.table
dt_fst_file = tempfile(fileext = ".fst")
fst::write_fst(data, dt_fst_file)
fst_dt = fst::fst(dt_fst_file)
class(fst_dt)
fst_dt
format(object.size(fst_dt), units = "Mb")
# key is preserved
dt = read_fst(dt_fst_file, as.data.table = TRUE)
key(dt)
format(object.size(dt), units = "Mb")
source('~/.active-rstudio-document', echo=TRUE)
estimateESTATICS <- function (mpmdata,
TEScale = 100,
dataScale = 1000,
method = c("NLR", "QL"),
sigma = NULL,
L = NULL,
maxR2star=50,
verbose = TRUE) {
# validate_MPMData(mpmdata)
## create the design matrix of the model
if (mpmdata$model == 2) {
xmat <- matrix(0, mpmdata$nFiles, 4)
xmat[1:length(mpmdata$t1Files), 1] <- 1
xmat[(length(mpmdata$t1Files) + 1):(length(mpmdata$t1Files) + length(mpmdata$mtFiles)), 2] <- 1
xmat[(length(mpmdata$t1Files) + length(mpmdata$mtFiles) + 1):mpmdata$nFiles, 3] <- 1
xmat[, 4] <- mpmdata$TE/TEScale
## ... for our model in estatics3() ...
## S_{T1} = par[1] * exp(- par[4] * TE)
## S_{MT} = par[2] * exp(- par[4] * TE)
## S_{PD} = par[3] * exp(- par[4] * TE)
} else if (mpmdata$model == 1) {
xmat <- matrix(0, mpmdata$nFiles, 3)
xmat[1:length(mpmdata$t1Files), 1] <- 1
xmat[(length(mpmdata$t1Files) + 1):mpmdata$nFiles, 2] <- 1
xmat[, 3] <- mpmdata$TE / TEScale
## ... for our model in estatics2() ...
## S_{T1} = par[1] * exp(- par[3] * TE)
## S_{PD} = par[2] * exp(- par[3] * TE)
} else {
xmat <- matrix(0, mpmdata$nFiles, 2)
xmat[1:length(mpmdata$t1Files), 1] <- 1
xmat[, 2] <- mpmdata$TE / TEScale
## ... for our model in estatics1() ...
## S_{T1} = par[1] * exp(- par[2] * TE)
}
if (verbose) {
cat("Design of the model:\n")
print(xmat)
}
## exclude all voxel from mask with all zeros for a modality
if (verbose) cat("Searching for voxel with zeros only ...")
zerovoxel <- apply(mpmdata$ddata <= 0, 2:4, any) & mpmdata$mask
mpmdata$mask[zerovoxel] <- FALSE
if (verbose) cat(" done\n")
## obbtain initial estimates from linearized model
thetas <- initth(mpmdata, TEScale, dataScale)
## prepare the standard deviation array in case of the quasi-likelihood estimation (QL)
if (method == "QL") {
sigma <- sigma/dataScale
CLarray <- sigma * sqrt(pi/2) * gamma(L + 0.5)/gamma(L)/gamma(1.5)
if (length(sigma) == 1) {
homsigma <- TRUE
sig <- sigma
CL <- CLarray
} else if (all(dim(sigma) == mpmdata$sdim)) {
homsigma <- FALSE
} else {
stop("Dimension of argument sigma does not match the data")
}
## create inde vectors for the data with different weighting (T1w, MTw, PDw)
indT1 <- order(mpmdata$TE[as.logical(xmat[, 1])])[1]
if (mpmdata$model == 2) {
indMT <- order(mpmdata$TE[as.logical(xmat[, 2])])[1] + sum(xmat[, 1])
indPD <- order(mpmdata$TE[as.logical(xmat[, 3])])[1] + sum(xmat[, 1]) + sum(xmat[, 2])
npar <- 4
} else if (mpmdata$model == 1) {
indPD <- order(mpmdata$TE[as.logical(xmat[, 2])])[1] + sum(xmat[, 1])
npar <- 3
} else {
npar <- 2
}
## create necessary arrays
isConv <- array(FALSE, mpmdata$sdim)
isThresh <- array(FALSE, mpmdata$sdim)
modelCoeff <- array(0, c(npar, mpmdata$sdim))
invCov <- array(0, c(npar, npar, mpmdata$sdim))
rsigma <- array(0, mpmdata$sdim)
if (verbose) cat("Start estimation", format(Sys.time()), "\n")
for (z in 1:mpmdata$sdim[3]) {
for (y in 1:mpmdata$sdim[2]) {
for (x in 1:mpmdata$sdim[1]) {
if (mpmdata$mask[x, y, z]) {
if (method == "QL") {
if(!homsigma) {
sig <- sigma[x, y, z]
CL <- CLarray[x, y, z]
}
ivec <- mpmdata$ddata[, x, y, z]/dataScale
th <- thetas[, x, y, z]
if (mpmdata$model == 2) {
res <- if (method == "NLR") try(nls(ivec ~ estatics3(par, xmat),
data = list(xmat = xmat),
start = list(par = th),
control = list(maxiter = 200,
warnOnly = TRUE)))
else try(nls(ivec ~ estatics3QL(par, xmat, CL, sig, L),
data = list(xmat = xmat,
CL = CL,
sig = sig,
L = L),
start = list(par = th),
control = list(maxiter = 200,
warnOnly = TRUE)))
} else if (mpmdata$model == 1) {
res <- if (method == "NLR") try(nls(ivec ~ estatics2(par, xmat),
data = list(xmat = xmat),
start = list(par = th),
control = list(maxiter = 200,
warnOnly = TRUE)))
else try(nls(ivec ~ estatics2QL(par, xmat, CL, sig, L),
data = list(xmat = xmat,
CL = CL,
sig = sig,
L = L),
start = list(par = th),
control = list(maxiter = 200,
warnOnly = TRUE)))
} else if (mpmdata$model == 0) {
res <- if (method == "NLR") try(nls(ivec ~ estatics1(par, xmat),
data = list(xmat = xmat),
start = list(par = th),
control = list(maxiter = 200,
warnOnly = TRUE)))
else try(nls(ivec ~ estatics1QL(par, xmat, CL, sig, L),
data = list(xmat = xmat,
CL = CL,
sig = sig,
L = L),
start = list(par = th),
control = list(maxiter = 200,
warnOnly = TRUE)))
}
if (class(res) != "try-error") {
sres <- getnlspars(res)
isConv[x, y, z] <- as.integer(res$convInfo$isConv)
modelCoeff[, x, y, z] <- sres$coefficients
if (sres$sigma != 0) {
invCovtmp <- sres$XtX
invCov[, , x, y, z] <- invCovtmp/sres$sigma^2
rsigma[x, y, z] <- sres$sigma
}
if (class(res) == "try-error" || coef(res)[npar] > maxR2star || coef(res)[npar] < 0) {
## fallback for not converged or R2star out of range
sres <- linearizedESTATICS(ivec, xmat, maxR2star)
## thats already the solution for NLR if R2star is fixed
isThresh[x, y, z] <- sres$invCov[npar, npar] == 0
isConv[x, y, z] <- 255 ## partially linearized NLR model
xmat0 <- sres$xmat
th <- sres$theta
modelCoeff[-npar, x, y, z] <- sres$theta
modelCoeff[npar, x, y, z] <- sres$R2star
if (sres$sigma2 != 0) {
invCov[, , x, y, z] <- sres$invCov
rsigma[x, y, z] <- sqrt(sres$sigma2)
}
if (method == "QL") {
xmat0 <- sres$xmat
# xmat0 containes design matrix for linear problem with fixed R2star
# ony have nonlinearity from QL
if (mpmdata$model == 2)
res <- try(nls(ivec ~ estatics3QLfixedR2(par, xmat, CL, sig, L),
data = list(xmat = xmat0,
CL = CL,
sig = sig,
L = L),
start = list(par = th),
control = list(maxiter = 200,
warnOnly = TRUE)))
else if (mpmdata$model == 1)
res <- try(nls(ivec ~ estatics2QLfixedR2(par, xmat, CL, sig, L),
data = list(xmat0 = xmat,
CL = CL,
sig = sig,
L = L),
start = list(par = th),
control = list(maxiter = 200,
warnOnly = TRUE)))
else if (mpmdata$model == 0)
res <- try(nls(ivec ~ estatics1QLfixedR2(par, xmat, CL, sig, L),
data = list(xmat0 = xmat,
CL = CL,
sig = sig,
L = L),
start = list(par = th),
control = list(maxiter = 200,
warnOnly = TRUE)))
if (class(res) != "try-error") {
isConv[x, y, z] <- as.integer(res$convInfo$isConv)
sres <- getnlspars(res)
modelCoeff[-npar, x, y, z] <- sres$coefficients
if (sres$sigma != 0) {
invCovtmp <- sres$XtX
invCov[-npar, -npar, x, y, z] <- invCovtmp/sres$sigma^2
rsigma[x, y, z] <- sres$sigma
}
} else {
mpmdata$mask[x, y, z] <- FALSE
}
}#fallback
}#mask
}#x
}#y
if (verbose) cat("z", z, "time", format(Sys.time()), "\n")
}#z
if (verbose) cat("Finished estimation", format(Sys.time()), "\n")
obj <- list(modelCoeff = modelCoeff,
invCov = invCov,
rsigma = rsigma,
isThresh = isThresh,
isConv = isConv,
sdim = mpmdata$sdim,
nFiles = mpmdata$nFiles,
t1Files = mpmdata$t1Files,
pdFiles = mpmdata$pdFiles,
mtFiles = mpmdata$mtFiles,
model = mpmdata$model,
maskFile = mpmdata$maskFile,
mask = mpmdata$mask,
sigma = sigma,
L = L,
TR = mpmdata$TR,
TE = mpmdata$TE,
FA = mpmdata$FA,
TEScale = TEScale,
dataScale = dataScale)
class(obj) <- "ESTATICSModel"
invisible(obj)
}
modelMPM <- estimateESTATICS(mpm,
method = "NLR",
verbose = FALSE)
devtools::load_all(".")
modelMPM <- estimateESTATICS(mpm,
method = "NLR",
verbose = FALSE)
# evaluate this here to be able to reduce the mask afterwards
# setCores(2)
modelMPMQLsp1 <- smoothESTATICS(modelMPM,
mpmData = extract(mpm, "ddata"),
kstar = 16,
alpha = 0.004,
patchsize = 1,
verbose = FALSE)
mpmsp1 <- mpm
mpmsp1$ddata <- modelMPMQLsp1$smoothedData
sigma <- array(50, mpm$sdim)
modelMPMQL2 <- estimateESTATICS(mpmsp1,
method = "QL",
sigma = sigma,
L = 1,
verbose = FALSE)
library(qMRI)
