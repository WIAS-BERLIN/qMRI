\documentclass[a4paper]{article}


\usepackage[style=authoryear,backend=bibtex,url=false]{biblatex} %backend tells biblatex what you will be using to process the bibliography file
\addbibresource{qmri}

\newcommand{\pkg}[1]{{\normalfont\fontseries{b}\selectfont #1}\index{Packages!#1}}
\let\proglang=\textsf
\let\code=\texttt
%\VignetteIndexEntry{Analyzing MPM data with package qMRI}

\title{An example session for analyzing quantitative MRI data in the Multi-Parameter Mapping framework}
\author{J\"org Polzehl and Karsten Tabelow}

\begin{document}
\SweaveOpts{concordance=TRUE}

\maketitle

\setkeys{Gin}{width=\textwidth}
This document illustrates the workflow of analyzing quantitative Magnetic Resonance Imaging 
data in the framework of Multi-Parameter Mapping (MPM) experiments~\parencite{Weiskopf2013}.
The example uses artificial noisy MPM data based on the analysis results of a publicly 
available MPM dataset, see \url{http://hmri.info}: The original data was modeled 
using the ESTATICS model~\parencite{Weiskopf2014}. Its four adaptively smoothed parameter 
maps were used to generate the artificial data on a selected (small) sub cube with Rician 
noise by creating corresponding signal echos following the ESTATICS model equation. 
The artificial data is supplied with this package together with the smoothed quantitative 
maps (relaxation rates $R_1$ and $R_2^\star$, proton density $P\!D$, and magnetization 
transfer $M\!T$) from the original data for ground truth comparison. 

Specifically, the data consist of, in total, 22 image volumes in NIfTI format that 
correspond to multiple echos of three different imaging modalities, i.e., 8 echos 
of $T_1$ weighted images, 8 echos of proton density ($P\!D$) weighted images and 
6 images from a dual excitation FLASH magnetization transfer ($M\!T$) weighted 
sequence. Each echo in the image volumes is ``acquired'' at an echo time, repetition time 
and flip angle, that equal those of the original experiment. The quantitative maps 
suffer from a $B_1$ transmit (and receive) bias, that can be corrected for, if the smooth 
$B_1$ correction field that affects the local flip angle is known~\parencite{Tabelow2019}.
An estimate for this field is supplied with the package, too. 

\section{Reading the MPM data}
<<0,echo=FALSE>>=
options(digits=3)
@
First, we specify the directory where the data are stored within the package
<<1>>=
dataDir <- system.file("extdata", package = "qMRI")
@

The filenames of the data correspond to the weighting of the imaging. We create 
the paths of the data files including the $B_1$ field map a mask file (which 
in this cases describes the whole data cube, only):
<<2>>=
t1Names <- paste0("t1w_", 1:8, ".nii.gz")
mtNames <- paste0("mtw_", 1:6, ".nii.gz")
pdNames <- paste0("pdw_", 1:8, ".nii.gz")
t1Files <- file.path(dataDir, t1Names)
mtFiles <- file.path(dataDir, mtNames)
pdFiles <- file.path(dataDir, pdNames)
B1File <- file.path(dataDir, "B1map.nii.gz")
maskFile <- file.path(dataDir, "mask.nii.gz")
@ 

The acquisition parameters (echo time ($T\!E$) in milliseconds, repetition time 
($T\!R$) in milliseconds and flip angle ($F\!A$) in degree) for each volume are 
replicated from the original MPM data:
<<3>>=
TE <- c(2.3, 4.6, 6.9, 9.2, 11.5, 13.8, 16.1, 18.4,
        2.3, 4.6, 6.9, 9.2, 11.5, 13.8,
        2.3, 4.6, 6.9, 9.2, 11.5, 13.8, 16.1, 18.4)
TR <- rep(25, 22)
FA <- c(rep(21, 8), rep(6, 6), rep(6, 8))
@


The package \pkg{pkg} provides a function \code{readMPMData} to read the data 
into an \proglang{R} session 
<<4>>=
library(qMRI)
mpm <- readMPMData(t1Files, pdFiles, mtFiles,
                   maskFile, 
                   TR = TR, TE = TE, FA = FA, 
                   verbose = FALSE)
@
which creates an object \code{mpm} of class \code{"MPMdata"}.

\section{Parameter estimation (ESTATICS)}

The ESTATICS model \parencite{Weiskopf2014} describes the data 
from an MPM sequence by the relaxation rate $R_2^\star$ for the 
signal decay with the echo time $T\!E$ and the three absolute 
values for $T\!E = 0$. Parameters in this model can be estimated by 
<<5>>=
modelMPM <- estimateESTATICS(mpm, 
                             method = "NLR", 
                             verbose = FALSE)
@
using nonlinear least-squares regression. However, the low 
low signal-to-noise ratio (SNR) in the data leads to a bias for the 
parameter estimates, see~\cite{PoTa2016} and \cite{Tabelow2017}.
Therefore the parameter estimation can alternatively be performed by 
<<6>>=
sigma <- array(50, mpm$sdim)
modelMPMQL <- estimateESTATICS(mpm, 
                               method = "QL",
                               sigma = sigma, 
                               L = 1, 
                               verbose = FALSE)
@
using a quasi-likelihood formulation~\parencite{PoTa2016, Tabelow2017}. 
It avoids, in case of low SNR, the bias caused by the skewness of the 
Rician signal distribution. The application of this method  
requires to specify the scale parameter $\sigma$ of the Rician distribution, 
which in this case of artificial data is explicitly known. 
Alternatively, a map of scale parameters
could be estimated using function \code{awslsigmc} from package \pkg{dti}
<<eval=FALSE>>=
ddata <- extract(mpm,"ddata")
if(require(dti)) sigma <- awslsigmc(ddata[1,,,],16)$sigma
@
see \cite{Tabelow2014a} for details of the method.

\section{Structural adaptive smoothing}

Data from MPM sequences suffer from noise hindering the quality of
the estimated quantitative maps. \cite{Tabelow2017a} introduced a 
structural adaptive smoothing method that can be used to reduce the 
variability of the estimated parameter maps and, if \code{mpmData} 
is specified, the observed image data:
<<7>>=
setCores(2)
modelMPMQLsp1 <- smoothESTATICS(modelMPM,
                                mpmData = extract(mpm, "ddata"),
                                kstar = 16,
                                alpha = 0.004,
                                patchsize = 1,
                                verbose = TRUE)
@
The package \pkg{qMRI} implements an extension of the method that 
uses the comparison of local patches for adaptive smoothing~\parencite{PoPaTa18}.
The resulting ESTATICS unsmoothed and smoothed parameter maps for the 
central coronal slice can be illustrated by
<<8, fig = TRUE, width = 12, height = 6.5>>=
library(adimpro)
rimage.options(zquantiles = c(.01, .99), ylab = "z")
par(mfrow = c(2, 4), 
    mar = c(3, 3, 3, 1), mgp = c(2, 1, 0))
pnames <- c("T1", "MT", "PD", "R2star")
for (i in 1:4) {
  rimage(modelMPMQL$modelCoeff[i, , 11, ])
  title(pnames[i])
}
for (i in 1:4) {
  rimage(modelMPMQLsp1$modelCoeff[i, , 11, ])
  title(paste("smoothed", pnames[i]))
}
@

The preceding code also applies the adaptive smoothing not only to the 
parameter maps of the ESTATICS model, but also to the data itself.
From this new parameter maps can be estimated by the quasi-likelihood 
formulation and thus avoiding the bias due to the skewness in the signal
distribution: 
<<9>>=
mpmsp1 <- mpm
mpmsp1$ddata <- modelMPMQLsp1$smoothedData
sigma <- array(50, mpm$sdim)
modelMPMQL2 <- estimateESTATICS(mpmsp1, 
                                method = "QL",
                                sigma = sigma, 
                                L = 1, 
                                verbose = FALSE)
@
Note, that we again employ the same Rician scale parameter, i.e., 
of the unprocessed data, cf. the discussion in \cite{PoTa2016}.



\section{Calculating quantitative maps}

Finally, from the (un)smoothed parameter maps of the ESTATICS model, we 
can compute the quantitative $R_1$, $R_2^\star$, $P\!D$ and $M\!T$ maps
<<10>>=
qMRIMaps <- calculateQI(modelMPM,
                        b1File = B1File,
                        TR2 = 3.4)
qMRIQLMaps <- calculateQI(modelMPMQL,
                          b1File = B1File,
                          TR2 = 3.4)
qMRIQLSmoothedp1Maps <- calculateQI(modelMPMQLsp1,
                                    b1File = B1File,
                                    TR2 = 3.4)
qMRIQL2Maps <- calculateQI(modelMPMQL2,
                           b1File = B1File,
                           TR2 = 3.4)
@
The calculation requires the $B_1$-bias field, if available, and the $T\!R_2$
parameter of the MTw sequence \parencite{Tabelow2019}.

We show the central coronal slice of the estimated quantitative maps together with the 
maps for the ground truth used to generate the data
<<11, fig = TRUE, width = 12, height = 13>>=
library(oro.nifti)
zlim <- matrix(c(0, 0, 0, 3000,
                 1.5, 35, 2, 10000),
               4, 2)
R1 <- readNIfTI(file.path(dataDir, "R1map.nii.gz"))
R2star <- readNIfTI(file.path(dataDir, "R2starmap.nii.gz"))
MT <- readNIfTI(file.path(dataDir, "MTmap.nii.gz"))
PD <- readNIfTI(file.path(dataDir, "PDmap.nii.gz"))
rimage.options(ylab = "z")
par(mfrow = c(4, 4),
    mar = c(3, 3, 3, 1), mgp = c(2, 1, 0))
nmaps <- c("R1", "R2star", "MT", "PD")
rimage(R1[, 11, ], zlim = zlim[1, ], 
       main = paste("true", nmaps[1]))
rimage(R2star[, 11, ], zlim = zlim[2, ], 
       main = paste("true", nmaps[2]))
rimage(MT[, 11, ], zlim = zlim[3, ], 
       main = paste("true", nmaps[3]))
rimage(PD[, 11, ], zlim = zlim[4, ], 
       main = paste("true", nmaps[4]))
qmap1 <- extract(qMRIQLMaps, nmaps)
for (i in 1:4) rimage(qmap1[[i]][, 11, ], zlim = zlim[i, ], 
                      main = paste("Estimated", nmaps[i]))
qmap2 <- extract(qMRIQLSmoothedp1Maps, nmaps)
for (i in 1:4) rimage(qmap2[[i]][, 11, ], zlim = zlim[i, ], 
                      main = paste("Smoothed", nmaps[i]))
qmap3 <- extract(qMRIQL2Maps, nmaps)
for (i in 1:4) rimage(qmap3[[i]][, 11, ], zlim = zlim[i, ],
                      main = paste("Smoothed data", nmaps[i]))
@

Using the quasi-likelihood estimation method is, for low SNR, supposed to 
reduce the bias caused by the skewness of the Rician distribution, 
cf.~\cite{PoTa2016} and \cite{Tabelow2017}.
<<12>>=
qmap0 <- extract(qMRIMaps,nmaps)
cat("\n", 
    "Bias of NLR estimates\n",
      "R1", mean(qmap0$R1-R1), 
      "R2star", mean(qmap0$R2star-R2star),
      "MT", mean(qmap0$MT-MT),
      "PD", mean(qmap0$PD-PD), "\n",
    "Bias of  QL estimates\n",
      "R1", mean(qmap1$R1-R1),
      "R2star", mean(qmap1$R2star-R2star),
      "MT", mean(qmap1$MT-MT),
      "PD", mean(qmap1$PD-PD), "\n")
@
Let's see which estimate performs best with respect to the root mean squared error (RMSE):
<<13>>=
cat("\n", 
    "Root mean squared error of NLR estimate\n",
      "R1", sqrt(mean((qmap0$R1-R1)^2)),
      "R2star", sqrt(mean((qmap0$R2star-R2star)^2)),
      "MT", sqrt(mean((qmap0$MT-MT)^2)),
      "PD", sqrt(mean((qmap0$PD-PD)^2)), "\n",
    "Root mean squared error of  QL estimate\n",
      "R1", sqrt(mean((qmap1$R1-R1)^2)),
      "R2star", sqrt(mean((qmap1$R2star-R2star)^2)),
      "MT", sqrt(mean((qmap1$MT-MT)^2)),
      "PD", sqrt(mean((qmap1$PD-PD)^2)),"\n",
    "Root mean squared error of smoothed QL estimate\n",
      "R1", sqrt(mean((qmap2$R1-R1)^2)),
      "R2star", sqrt(mean((qmap2$R2star-R2star)^2)),
      "MT", sqrt(mean((qmap2$MT-MT)^2)),
      "PD", sqrt(mean((qmap2$PD-PD)^2)),"\n",
    "Root mean squared error of QL estimate from smoothed data \n",
      "R1", sqrt(mean((qmap3$R1-R1)^2)),
      "R2star", sqrt(mean((qmap3$R2star-R2star)^2)),
      "MT", sqrt(mean((qmap3$MT-MT)^2)),
      "PD", sqrt(mean((qmap3$PD-PD)^2)),"\n")
@
For interpretation we need to compare this to the mean parameter values
<<14>>=
cat("\n", "Mean R1", mean(R1), "Mean R2star", mean(R2star), 
          "Mean MT", mean(MT), "Mean PD", mean(PD),"\n")
@
We see here, that using the quasi-likelihood estimation is supposed to 
reduce the bias of the estimated ESTATICS parameters, but does so
at the cost of a slightly increased variance. Structural adaptive 
smoothing leads to a considerable reduction in RMSE. 
Modelling of the spatially smoothed data has the additional effect of 
reduced bias originating from data variability.

\printbibliography

\end{document}